//
//  Logging.swift
//  GesfrotaUI
//
//  Created by Pedro Cavaleiro on 15/07/2025.
//
//  Docs Generated by Claude Sonnet 4
//

import Foundation
import ZIPFoundation

fileprivate typealias Logger = SimpleLogger

/// A comprehensive logging utility for application-wide log collection, persistence, and analysis.
///
/// The `SimpleLogger` type provides a centralized, static logging system with file-based persistence,
/// categorized severity levels, and robust log management capabilities. It supports structured
/// logging with contextual information, automatic file organization, and performance-optimized storage.
///
/// The name can be simplified by declaring a type alias such as `typealias Logger = SimpleLogger`
///
/// ## Features
/// - **Structured Logging**: Captures context including file, function, and line number automatically
/// - **Severity Levels**: Five-tier logging levels from debug to critical for proper categorization
/// - **File Persistence**: JSON-based storage with automatic file management and size limits
/// - **Log Analysis**: Statistical summaries and level-based counting for log files
/// - **Memory Management**: Automatic log rotation when files exceed size thresholds
/// - **Environment Snapshots**: Capability to capture complete application state for debugging
///
/// ## Usage Context
/// This utility is used throughout the application for debugging, error tracking, performance monitoring,
/// and compliance logging. It provides developers with detailed execution traces and administrators
/// with comprehensive audit trails.
///
/// ## Environment Requirements
/// - **Foundation Framework**: Uses FileManager for document directory access and file operations
/// - **Document Directory**: Requires write access to the application's document directory
/// - **JSON Encoding**: Depends on Codable protocol for log entry serialization
/// - **Main Actor**: All operations are main-actor isolated for thread safety
///
/// - Note: Log files are automatically managed with size limits to prevent excessive storage usage.
/// - Important: All methods are static; no singleton instance is required. Call directly via `SimpleLogger.methodName(...)`.
@MainActor
public class SimpleLogger {

    // MARK: - Properties
    
    /// The directory name used for storing log files within the document directory.
    ///
    /// All log files are organized within this subdirectory to maintain clean separation
    /// from other application data and enable easy log management.
    private static let loggingDirectoryName = "logging"

    // MARK: - Reading Methods
    
    /// Lists all log files with comprehensive metadata and statistical analysis.
    ///
    /// Scans the logging directory and generates detailed summaries for each log file,
    /// including file size, modification timestamps, and categorized entry counts by severity level.
    /// This method provides administrators and developers with overview information for log management.
    ///
    /// The analysis process includes:
    /// 1. **Directory Scanning**: Enumerates all JSON files in the logging directory
    /// 2. **Metadata Extraction**: Retrieves file size and last modification date
    /// 3. **Content Analysis**: Parses log entries and counts occurrences by severity level
    /// 4. **Summary Generation**: Creates structured summaries with all relevant information
    ///
    /// - Returns: Array of `LogFileSummary` objects containing file metadata and statistics,
    ///           or empty array if logging directory is inaccessible
    ///
    /// - Note: Only processes files with `.json` extension to avoid non-log files
    public static func listLogFiles() -> [LogFileSummary] {
        let fileManager = FileManager.default
        guard let docsURL = fileManager.urls(for: .documentDirectory, in: .userDomainMask).first else {
            return []
        }
        let dirURL = docsURL.appendingPathComponent(Self.loggingDirectoryName)
        guard let files = try? fileManager.contentsOfDirectory(at: dirURL, includingPropertiesForKeys: [.fileSizeKey, .contentModificationDateKey], options: []) else {
            return []
        }
        var summaries: [LogFileSummary] = []
        for fileURL in files where fileURL.pathExtension == "json" {
            let fileName = fileURL.lastPathComponent
            let attributes = try? fileManager.attributesOfItem(atPath: fileURL.path)
            let size = attributes?[.size] as? Int ?? 0
            let lastModified = attributes?[.modificationDate] as? Date ?? Date(timeIntervalSince1970: 0)
            // Parse and count log levels
            var levelCounts: [LogLevel: Int] = [:]
            if let data = try? Data(contentsOf: fileURL),
               let entries = try? JSONDecoder().decode([LogEntry].self, from: data) {
                for entry in entries {
                    levelCounts[entry.level, default: 0] += 1
                }
            }
            let fileNameWithoutExtension = fileName.replacingOccurrences(of: ".json", with: "").replacingOccurrences(of: ".swift", with: "")
            let summary = LogFileSummary(
                fileName: fileNameWithoutExtension,
                size: size,
                lastModified: lastModified,
                levelCounts: levelCounts
            )
            summaries.append(summary)
        }
        return summaries
    }
    
    /// Calculates aggregate statistics for all log files in the logging directory.
    ///
    /// Provides quick overview metrics for log file management, including total file count
    /// and cumulative storage usage. This information is useful for monitoring storage consumption
    /// and determining when log cleanup operations may be necessary.
    ///
    /// The calculation process:
    /// 1. **Directory Access**: Locates and accesses the logging directory
    /// 2. **File Enumeration**: Counts only JSON log files, excluding other file types
    /// 3. **Size Aggregation**: Sums individual file sizes for total storage usage
    /// 4. **Error Handling**: Gracefully handles inaccessible files or directories
    ///
    /// - Returns: A tuple containing:
    ///   - `fileCount`: Number of log files in the directory
    ///   - `totalSize`: Combined size of all log files in bytes
    ///
    /// Returns `(0, 0)` if the logging directory is inaccessible or contains no log files.
    public static func logFileStats() -> (fileCount: Int, totalSize: Int) {
        let fileManager = FileManager.default
        guard let docsURL = fileManager.urls(for: .documentDirectory, in: .userDomainMask).first else {
            return (0, 0)
        }
        let dirURL = docsURL.appendingPathComponent(Self.loggingDirectoryName)
        guard let files = try? fileManager.contentsOfDirectory(at: dirURL, includingPropertiesForKeys: [.fileSizeKey], options: []) else {
            return (0, 0)
        }
        var fileCount = 0
        var totalSize = 0
        for fileURL in files where fileURL.pathExtension == "json" {
            fileCount += 1
            if let attributes = try? fileManager.attributesOfItem(atPath: fileURL.path),
               let size = attributes[.size] as? Int {
                totalSize += size
            }
        }
        return (fileCount, totalSize)
    }

    /// Loads and returns all log entries from a specified log file in reverse chronological order.
    ///
    /// Retrieves complete log history from a specific file, presenting entries with the most recent
    /// first for optimal viewing and analysis. This method handles file access, JSON parsing,
    /// and data transformation automatically.
    ///
    /// The loading process includes:
    /// 1. **File Resolution**: Constructs the full file path with proper extension handling
    /// 2. **Data Loading**: Reads JSON content from the specified log file
    /// 3. **Deserialization**: Converts JSON data to structured LogEntry objects
    /// 4. **Chronological Ordering**: Reverses entries to show most recent first
    /// 5. **Error Recovery**: Returns empty array for missing or corrupted files
    ///
    /// - Parameter fileName: The base name of the log file without extension
    ///   (e.g., "MyViewController.swift" or "MyViewController")
    ///
    /// - Returns: Array of `LogEntry` objects in reverse chronological order,
    ///           or empty array if file doesn't exist or cannot be read
    ///
    /// - Note: Automatically appends `.swift.json` extension to the provided filename
    public static func loadLogEntries(fromFileNamed fileName: String) -> [LogEntry] {
        let fileManager = FileManager.default
        guard let docsURL = fileManager.urls(for: .documentDirectory, in: .userDomainMask).first else {
            return []
        }
        let dirURL = docsURL.appendingPathComponent("logging")
        let fileURL = dirURL.appendingPathComponent("\(fileName).swift.json")
        guard let data = try? Data(contentsOf: fileURL) else {
            return []
        }
        let entries = (try? JSONDecoder().decode([LogEntry].self, from: data)) ?? []
        return entries.reversed()
    }

    // MARK: - Logging Methods
    
    /// Logs a message with comprehensive contextual information for debugging and tracing.
    ///
    /// Creates a structured log entry with automatic context capture including source file,
    /// function name, and line number. This method provides the primary logging interface
    /// for simple text messages with optional severity level specification.
    ///
    /// The logging process includes:
    /// 1. **Context Capture**: Automatically records calling context using compiler directives
    /// 2. **Entry Creation**: Constructs structured LogEntry with all contextual information
    /// 3. **File Organization**: Groups entries by source file for logical organization
    /// 4. **Persistence**: Appends entry to appropriate log file with atomic operations
    ///
    /// - Parameters:
    ///   - message: The informational content to log
    ///   - level: The severity level for categorization (defaults to `.info`)
    ///   - file: Source file path (automatically filled by compiler)
    ///   - function: Function name where log is called (automatically filled)
    ///   - line: Line number of the log call (automatically filled)
    ///   - timestamp: Time of log creation (defaults to current time)
    ///
    /// - Note: Context parameters are automatically filled and should not be manually specified
    public static func log(
        _ message: String,
        level: LogLevel = .info,
        isSnapshot: Bool = false,
        file: String = #file,
        function: String = #function,
        line: Int = #line,
        timestamp: Date = Date()
    ) {
        // Extract base filename (e.g., "MyViewController.swift")
        let baseFileName = URL(fileURLWithPath: file).lastPathComponent
        let entry = LogEntry(
            message: message,
            level: level,
            isSnapshot: isSnapshot,
            file: file,
            function: function,
            line: line,
            timestamp: timestamp
        )
        appendLogEntryToDisk(forFileName: baseFileName, entry: entry)
    }
    
    /// Logs a message along with a structured data object for comprehensive debugging.
    ///
    /// Provides enhanced logging capabilities by combining text messages with serialized
    /// data objects. This method is particularly useful for debugging complex state changes,
    /// API responses, or data transformations where both context and data are important.
    ///
    /// The enhanced logging process includes:
    /// 1. **Message Encoding**: Serializes the message string to JSON format
    /// 2. **Object Serialization**: Converts the provided Codable object to JSON representation
    /// 3. **Type Information**: Records the object's type name for debugging context
    /// 4. **Entry Creation**: Constructs comprehensive LogEntry with all information
    /// 5. **File Persistence**: Appends the enriched entry to the appropriate log file
    ///
    /// - Parameters:
    ///   - message: The descriptive text message providing context for the logged data
    ///   - data: Optional Codable object to serialize and include with the log entry
    ///   - level: The severity level for categorization (defaults to `.info`)
    ///   - file: Source file path (automatically filled by compiler)
    ///   - function: Function name where log is called (automatically filled)
    ///   - line: Line number of the log call (automatically filled)
    ///   - timestamp: Time of log creation (defaults to current time)
    ///
    /// - Note: Both message and data objects are JSON-encoded for consistent storage format
    /// - Important: Force unwrapping is used for JSON encoding - ensure objects are properly Codable
    public static func log<T: Codable>(
        _ message: String,
        _ data: T?,
        level: LogLevel = .info,
        isSnapshot: Bool = false,
        file: String = #file,
        function: String = #function,
        line: Int = #line,
        timestamp: Date = Date()
    ) {
        let baseFileName = URL(fileURLWithPath: file).lastPathComponent
        let entry = LogEntry(
            message: String(data: try! JSONEncoder().encode(message), encoding: .utf8)!,
            objectName: String(describing: T.self),
            objectData: data != nil ? String(data: try! JSONEncoder().encode(data!), encoding: .utf8) : nil,
            level: level,
            isSnapshot: isSnapshot,
            file: file,
            function: function,
            line: line,
            timestamp: timestamp
        )
        appendLogEntryToDisk(forFileName: baseFileName, entry: entry)
    }
    
    // MARK: - File Persistence

    /// Appends a log entry to its corresponding JSON file with automatic file management.
    ///
    /// Handles the persistence logic for log entries, including file creation, content loading,
    /// size management, and atomic writing operations. This method ensures data integrity
    /// and implements automatic log rotation to prevent excessive file growth.
    ///
    /// The persistence process includes:
    /// 1. **File Location**: Resolves the target log file URL for the specified filename
    /// 2. **Content Loading**: Reads existing log entries if the file already exists
    /// 3. **Size Management**: Implements automatic rotation when files exceed 10MB limit
    /// 4. **Entry Rotation**: Removes oldest entries (up to 5) when size threshold is reached
    /// 5. **Data Appending**: Adds the new entry to the existing collection
    /// 6. **Atomic Writing**: Saves the updated log file with atomic operations
    ///
    /// - Parameters:
    ///   - fileName: Base name of the target log file (without extension)
    ///   - entry: The LogEntry object to append to the file
    ///
    /// - Note: Implements 10MB file size limit with automatic cleanup of oldest entries
    /// - Important: Uses atomic writing to prevent data corruption during file updates
    private static func appendLogEntryToDisk(forFileName fileName: String, entry: LogEntry) {
        guard let url = logFileURL(forFileName: fileName) else { return }
        var entries: [LogEntry] = []
        if let data = try? Data(contentsOf: url) {
            if let decoded = try? JSONDecoder().decode([LogEntry].self, from: data) {
                entries = decoded
            }
        }
        
        if let fileSize = (try? FileManager.default.attributesOfItem(atPath: url.path)[.size] as? NSNumber)?.intValue, fileSize >= 10_485_760, entries.count > 0 {
            let removeCount = min(5, entries.count)
            entries.removeFirst(removeCount)
        }
        entries.append(entry)
        do {
            let newData = try JSONEncoder().encode(entries)
            try newData.write(to: url, options: .atomic)
        } catch {
            print("Logging: Failed to append log for \(fileName): \(error)")
        }
    }
    
    /// Captures comprehensive environment snapshots for debugging and diagnostics.
    ///
    /// Creates detailed snapshots of one or more application components and their current state,
    /// providing developers with complete environmental context for debugging complex issues.
    /// This method is particularly useful for capturing system state before or after critical operations.
    ///
    /// The snapshot process supports any number of `Codable` components, such as:
    /// - **AppState**: Complete application state including user session and configuration
    /// - **SettingsManager**: Current settings manager state and user preferences
    /// - **GeofenceResolver**: Active geofence data and location-based configurations
    ///
    /// Each snapshot is logged with debug-level severity and synthetic file/function information
    /// to clearly identify these as environment snapshots rather than regular log entries.
    ///
    /// Example:
    /// ```swift
    /// snapshot(appState, SettingsDebug(), GeofenceResolver.shared.geofences)
    /// ```
    ///
    /// - Parameter items: A variadic list of environment components conforming to `Codable`
    ///
    /// - Note: All snapshots use debug-level logging and synthetic source information.
    /// - Important: Each component must conform to `Codable` so it can be serialized and logged.
    public static func snapshot(_ items: any Codable...) {
        for item in items {
            let typeName = String(describing: type(of: item))
            log(
                "\(typeName) Snapshot",
                item,
                level: .debug,
                file: "\(typeName).swift",
                function: "<environment snapshot>",
                line: 0
            )
        }
    }
       
    /// Deletes all log files in the logging directory for complete log cleanup.
    ///
    /// Performs a comprehensive cleanup operation by removing all JSON log files from the
    /// logging directory. This method is useful for maintenance operations, privacy compliance,
    /// or when starting fresh log collection cycles.
    ///
    /// The cleanup process:
    /// 1. **Directory Access**: Locates the logging directory within document storage
    /// 2. **File Enumeration**: Identifies all JSON files in the logging directory
    /// 3. **Selective Removal**: Deletes only log files (JSON extension) to preserve other data
    /// 4. **Error Tolerance**: Continues operation even if individual file deletions fail
    ///
    /// - Note: Only removes files with `.json` extension to avoid deleting non-log files
    /// - Important: This operation is irreversible - all log history will be permanently lost
    public static func clearLogs() {
        let fileManager = FileManager.default
        guard let docsURL = fileManager.urls(for: .documentDirectory, in: .userDomainMask).first else {
            return
        }
        let dirURL = docsURL.appendingPathComponent(Self.loggingDirectoryName)
        guard let files = try? fileManager.contentsOfDirectory(at: dirURL, includingPropertiesForKeys: nil, options: []) else {
            return
        }
        for fileURL in files where fileURL.pathExtension == "json" {
            try? fileManager.removeItem(at: fileURL)
        }
    }
    
    /// Deletes a specific log file by its base filename for targeted log management.
    ///
    /// Provides granular control over log file management by allowing removal of individual
    /// log files based on their source component or module. This method is useful for
    /// component-specific cleanup or when addressing storage concerns for particular modules.
    ///
    /// The deletion process:
    /// 1. **URL Resolution**: Constructs the complete file path from the base filename
    /// 2. **Existence Check**: Verifies the file exists before attempting deletion
    /// 3. **Safe Removal**: Performs deletion with error handling to prevent crashes
    /// 4. **Extension Handling**: Automatically manages file extension requirements
    ///
    /// - Parameter fileName: The base name of the log file to delete
    ///   (e.g., "MyViewController.swift" or "MyViewController")
    ///
    /// - Note: Automatically handles file extension and path construction
    /// - Important: Deletion is permanent and cannot be undone
    public static func deleteLogFile(named fileName: String) {
        let fileManager = FileManager.default
        guard let url = logFileURL(forFileName: fileName) else { return }
        if fileManager.fileExists(atPath: url.path) {
            try? fileManager.removeItem(at: url)
        }
    }
    
    /// Creates a compressed ZIP archive containing all log files for export or transmission.
    ///
    /// Generates a complete collection of all JSON log files in a single ZIP archive, making it
    /// convenient for sharing logs with support teams, backing up log data, or transmitting
    /// diagnostic information. This method handles the entire archival process automatically,
    /// including temporary file management and cleanup.
    ///
    /// The archival process includes:
    /// 1. **Directory Enumeration**: Scans the logging directory for all JSON log files
    /// 2. **Archive Creation**: Creates a temporary ZIP file with a unique identifier
    /// 3. **File Compression**: Adds each log file to the archive with DEFLATE compression
    /// 4. **Data Extraction**: Reads the completed ZIP archive into memory as Data
    /// 5. **Cleanup**: Automatically removes temporary files after processing
    ///
    /// ## Use Cases
    /// - **Bug Reports**: Attach comprehensive log data to support tickets
    /// - **Backup Operations**: Create portable backups of application logs
    /// - **Remote Diagnostics**: Send complete log history to development teams
    /// - **Compliance**: Generate audit trails for regulatory requirements
    ///
    /// ## Performance Considerations
    /// This method loads all log files into memory simultaneously and may consume significant
    /// resources if log files are large or numerous. Consider using `clearLogs()` periodically
    /// to manage log file sizes.
    ///
    /// - Returns: Compressed ZIP archive as `Data` containing all log files, or `nil` if:
    ///   - Document directory is inaccessible
    ///   - Logging directory doesn't exist or is empty
    ///   - ZIP archive creation fails
    ///   - File I/O operations encounter errors
    ///
    /// ## Example
    /// ```swift
    /// if let zipData = SimpleLogger.gatherFiles() {
    ///     // Save to file, share via email, or upload to server
    ///     try zipData.write(to: exportURL)
    /// } else {
    ///     print("No log files available for export")
    /// }
    /// ```
    ///
    /// - Note: Creates and automatically cleans up temporary files during the archival process
    /// - Important: Returns `nil` if no log files exist or if any step in the process fails
    public static func gatherFiles() -> Data? {
        let fileManager = FileManager.default
        guard let docsURL = fileManager.urls(for: .documentDirectory, in: .userDomainMask).first else { return nil }
        let logsDir = docsURL.appendingPathComponent(loggingDirectoryName)

        guard let enumerator = fileManager.enumerator(at: logsDir, includingPropertiesForKeys: nil) else { return nil }
        let logFiles = enumerator.compactMap { $0 as? URL }.filter { $0.pathExtension == "json" }
        guard !logFiles.isEmpty else { return nil }
        
        let tempZipURL = URL(fileURLWithPath: NSTemporaryDirectory()).appendingPathComponent(UUID().uuidString + ".zip")
        defer { try? fileManager.removeItem(at: tempZipURL) }

        let archive: Archive
        do {
            archive = try Archive(url: tempZipURL, accessMode: .create)
        } catch {
            Logger.log("Failed to create zip archive: \(error)", level: .error)
            return nil
        }

        for fileURL in logFiles {
            if let data = try? Data(contentsOf: fileURL) {
                do {
                    try archive.addEntry(with: fileURL.lastPathComponent, type: .file, uncompressedSize: Int64(data.count), compressionMethod: .deflate, provider: { position, size in
                        return data.subdata(in: Int(position)..<Int(position)+size)
                    })
                } catch {
                    Logger.log("Failed to add entry to zip: \(error)", level: .error)
                    return nil
                }
            }
        }

        // Read ZIP contents as Data
        return try? Data(contentsOf: tempZipURL)
    }

    /// Constructs the complete file URL for a log file with automatic directory management.
    ///
    /// Provides centralized file path resolution for log files, including automatic creation
    /// of the logging directory structure when needed. This method ensures consistent file
    /// organization and handles the infrastructure requirements for log persistence.
    ///
    /// The URL construction process:
    /// 1. **Document Directory**: Locates the application's document directory
    /// 2. **Logging Subdirectory**: Constructs path to the dedicated logging folder
    /// 3. **Directory Creation**: Creates the logging directory if it doesn't exist
    /// 4. **File Path Assembly**: Combines directory path with filename and JSON extension
    /// 5. **Error Handling**: Returns nil if document directory is inaccessible
    ///
    /// - Parameter filename: The base name of the log file (without extension)
    ///
    /// - Returns: Complete URL to the log file, or `nil` if the document directory
    ///           cannot be accessed or directory creation fails
    ///
    /// - Note: Automatically appends `.json` extension to the provided filename
    /// - Important: Creates logging directory structure if it doesn't exist
    private static func logFileURL(forFileName filename: String) -> URL? {
        let fileManager = FileManager.default
        guard let docsURL = fileManager.urls(for: .documentDirectory, in: .userDomainMask).first else {
            return nil
        }
        let dirURL = docsURL.appendingPathComponent(Self.loggingDirectoryName)
        if !fileManager.fileExists(atPath: dirURL.path) {
            try? fileManager.createDirectory(at: dirURL, withIntermediateDirectories: true)
        }
        return dirURL.appendingPathComponent("\(filename).json")
    }
    
}
